name: Ecowitt updater

on:
  workflow_dispatch:
  schedule:
    - cron: "*/5 * * * *"

concurrency:
  group: ecowitt-updater
  cancel-in-progress: true

permissions:
  contents: write

jobs:
  update:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi

      - name: Fetch Ecowitt history (5min) and append
        env:
          ECOWITT_APPLICATION_KEY: ${{ secrets.ECOWITT_APPLICATION_KEY }}
          ECOWITT_API_KEY: ${{ secrets.ECOWITT_API_KEY }}
          ECOWITT_MAC: ${{ secrets.ECOWITT_MAC }}
        run: |
          python - <<'PY'
          import json, os, time
          from datetime import datetime, timezone
          from pathlib import Path
          import urllib.request, urllib.parse

          HISTORY_PATH = Path("data") / "history.json"
          HEARTBEAT_DIR = Path("heartbeat")
          HEARTBEAT_PATH = HEARTBEAT_DIR / "heartbeat.json"

          app_key = os.getenv("ECOWITT_APPLICATION_KEY")
          api_key = os.getenv("ECOWITT_API_KEY")
          mac = os.getenv("ECOWITT_MAC")
          if not (app_key and api_key and mac):
              raise SystemExit("Falten secrets: ECOWITT_APPLICATION_KEY / ECOWITT_API_KEY / ECOWITT_MAC")

          def fnum(x):
              try:
                  return float(x)
              except Exception:
                  return None

          def f_to_c(v):
              try:
                  return (float(v) - 32.0) * 5.0 / 9.0
              except Exception:
                  return None

          def mph_to_kmh(v):
              try:
                  return float(v) * 1.609344
              except Exception:
                  return None

          def ms_to_kmh(v):
              try:
                  return float(v) * 3.6
              except Exception:
                  return None

          def to_ms_epoch(s):
              # Accepta segons o ms
              if s is None:
                  return None
              try:
                  x = float(s)
                  if x > 1e12:  # ja és ms
                      return int(x)
                  if x > 1e9:   # segons unix
                      return int(x * 1000)
              except Exception:
                  pass
              return None

          def read_hist():
              if HISTORY_PATH.exists():
                  try:
                      h = json.loads(HISTORY_PATH.read_text(encoding="utf-8"))
                      if isinstance(h, list):
                          return h
                  except Exception:
                      pass
              return []

          def write_hist(hist):
              HISTORY_PATH.parent.mkdir(parents=True, exist_ok=True)
              HISTORY_PATH.write_text(json.dumps(hist, ensure_ascii=False), encoding="utf-8")

          def write_heartbeat(now_ms):
              HEARTBEAT_DIR.mkdir(parents=True, exist_ok=True)
              hb = {"run_ts": now_ms, "run_iso_utc": datetime.now(timezone.utc).isoformat()}
              HEARTBEAT_PATH.write_text(json.dumps(hb, ensure_ascii=False), encoding="utf-8")
              return hb

          # 1) Carrega històric i calcula finestra
          hist = read_hist()
          hist = [h for h in hist if isinstance(h, dict) and isinstance(h.get("ts"), (int, float))]
          hist.sort(key=lambda x: int(x["ts"]))  # IMPORTANT: assegura ordre

          now_ms = int(time.time() * 1000)
          cutoff_ms = now_ms - 24 * 60 * 60 * 1000

          last_ts_ms = int(hist[-1]["ts"]) if hist else None

          # SOLAPAMENT per evitar perdre punts per retard (15 min)
          OVERLAP_MS = 15 * 60 * 1000

          if last_ts_ms is None:
              start_ms = cutoff_ms
          else:
              start_ms = max(last_ts_ms - OVERLAP_MS, cutoff_ms)

          end_ms = now_ms

          start_s = int(start_ms / 1000)
          end_s = int(end_ms / 1000)

          # 2) Crida API històrica (5 min)
          base_url = "https://api.ecowitt.net/api/v3/device/history"
          params = {
              "application_key": app_key,
              "api_key": api_key,
              "mac": mac,
              "cycle_type": "5min",
              "call_back": "all",
              "start_time": start_s,
              "end_time": end_s,
          }
          url = base_url + "?" + urllib.parse.urlencode(params)

          with urllib.request.urlopen(url, timeout=30) as r:
              payload = json.loads(r.read().decode("utf-8"))

          if not isinstance(payload, dict):
              raise SystemExit(f"Resposta inesperada: {type(payload)}")

          data = payload.get("data") or payload.get("datas") or payload.get("result") or payload.get("records")
          if data is None:
    print("Ecowitt: cap dada nova encara (data=null).")
    write_heartbeat(now_ms)
    print("Heartbeat escrit. Sortida neta.")
    exit(0)

          if isinstance(data, dict):
              data_list = data.get("list") or data.get("data") or data.get("records")
          else:
              data_list = data

          if not isinstance(data_list, list):
              raise SystemExit(f"Format històric inesperat: {type(data_list)}")

          def val_unit(x):
              if isinstance(x, dict):
                  return fnum(x.get("value")), (x.get("unit") or x.get("units"))
              return fnum(x), None

          def pick(d, *keys):
              cur = d
              for k in keys:
                  if not isinstance(cur, dict) or k not in cur:
                      return None
                  cur = cur[k]
              return cur

          def parse_row(r):
              ts_ms = (
                  to_ms_epoch(r.get("ts")) or
                  to_ms_epoch(r.get("time")) or
                  to_ms_epoch(r.get("timestamp")) or
                  to_ms_epoch(r.get("dateutc")) or
                  None
              )

              if ts_ms is None and isinstance(r.get("time"), str):
                  try:
                      dt = datetime.strptime(r["time"], "%Y-%m-%d %H:%M").replace(tzinfo=timezone.utc)
                      ts_ms = int(dt.timestamp() * 1000)
                  except Exception:
                      ts_ms = None

              if ts_ms is None:
                  return None

              t_raw, t_unit = val_unit(pick(r, "outdoor", "temperature") or r.get("temperature") or r.get("temp"))
              h_raw, h_unit = val_unit(pick(r, "outdoor", "humidity") or r.get("humidity"))
              d_raw, d_unit = val_unit(pick(r, "outdoor", "dew_point") or r.get("dew_point"))

              temp_c = t_raw
              if t_raw is not None:
                  if (t_unit and str(t_unit).lower().startswith("f")) or (t_raw >= 80):
                      temp_c = f_to_c(t_raw)

              dew_c = d_raw
              if d_raw is not None:
                  if (d_unit and str(d_unit).lower().startswith("f")) or (d_raw >= 80):
                      dew_c = f_to_c(d_raw)

              hum_pct = h_raw

              w_raw, w_unit = val_unit(r.get("wind_speed") or pick(r, "wind", "wind_speed"))
              g_raw, g_unit = val_unit(r.get("wind_gust") or pick(r, "wind", "wind_gust"))
              wind_dir = (r.get("wind_direction") or pick(r, "wind", "wind_direction"))

              def norm_w(v, unit):
                  if v is None:
                      return None
                  u = (str(unit).lower() if unit else "")
                  if "mph" in u:
                      return mph_to_kmh(v)
                  if u in ("m/s", "ms", "mps"):
                      return ms_to_kmh(v)
                  return float(v)

              wind_kmh = norm_w(w_raw, w_unit)
              gust_kmh = norm_w(g_raw, g_unit)

              rd_raw, rd_unit = val_unit(r.get("rainfall_daily") or pick(r, "rainfall", "daily") or r.get("rain_day"))
              rr_raw, rr_unit = val_unit(r.get("rain_rate") or pick(r, "rainfall", "rate") or r.get("rain_rate"))

              return {
                  "ts": int(ts_ms),
                  "temp_c": None if temp_c is None else float(temp_c),
                  "hum_pct": None if hum_pct is None else float(hum_pct),
                  "dew_c": None if dew_c is None else float(dew_c),
                  "wind_kmh": None if wind_kmh is None else float(wind_kmh),
                  "gust_kmh": None if gust_kmh is None else float(gust_kmh),
                  "wind_dir": (str(wind_dir) if wind_dir is not None else None),
                  "rain_day_mm": rd_raw,
                  "rain_rate_mmh": rr_raw,
              }

          new_rows = []
          for r in data_list:
              if not isinstance(r, dict):
                  continue
              row = parse_row(r)
              if row is None:
                  continue
              # IMPORTANT: com que fem overlap, només considerem "nou" el que supera l'últim ts guardat
              if last_ts_ms is None or row["ts"] > last_ts_ms:
                  new_rows.append(row)

          merged = hist + new_rows

          # Dedupe per ts (si arriba el mateix ts amb valors més complets, el nou guanya)
          by_ts = {}
          for r in merged:
              ts = r.get("ts")
              if not isinstance(ts, (int, float)):
                  continue
              by_ts[int(ts)] = r

          merged = [by_ts[k] for k in sorted(by_ts.keys())]
          merged = [r for r in merged if r["ts"] >= cutoff_ms]

          write_hist(merged)
          hb = write_heartbeat(now_ms)

          print(f"Window request (s): {start_s}->{end_s} | overlap={OVERLAP_MS//60000}min | last_ts={last_ts_ms}")
          print(f"Fetched {len(new_rows)} NEW rows. Total kept: {len(merged)}")
          print("Heartbeat:", hb)
          PY

      - name: Commit & push (only if changed)
        run: |
          set -e

          if git diff --quiet; then
            echo "No changes to commit."
            exit 0
          fi

          git config user.name "github-actions"
          git config user.email "github-actions@users.noreply.github.com"

          git add data/history.json heartbeat/heartbeat.json
          git commit -m "Update meteo data" || true

          git pull --rebase origin main

          git add data/history.json heartbeat/heartbeat.json
          git commit -m "Update meteo data" || true

          for i in 1 2 3; do
            if git push origin HEAD:main; then
              echo "Push OK"
              exit 0
            fi
            echo "Push fallit (intent $i). Reintentant..."
            git pull --rebase origin main
          done

          echo "ERROR: No s'ha pogut fer push després de reintents."
          exit 1
